"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/gtoken";
exports.ids = ["vendor-chunks/gtoken"];
exports.modules = {

/***/ "(rsc)/./node_modules/gtoken/build/cjs/src/index.cjs":
/*!*****************************************************!*\
  !*** ./node_modules/gtoken/build/cjs/src/index.cjs ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.GoogleToken = void 0;\nvar fs = _interopRequireWildcard(__webpack_require__(/*! fs */ \"fs\"));\nvar _gaxios = __webpack_require__(/*! gaxios */ \"(rsc)/./node_modules/gaxios/build/cjs/src/index.js\");\nvar jws = _interopRequireWildcard(__webpack_require__(/*! jws */ \"(rsc)/./node_modules/jws/index.js\"));\nvar path = _interopRequireWildcard(__webpack_require__(/*! path */ \"path\"));\nvar _util = __webpack_require__(/*! util */ \"util\");\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, \"default\": e }; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t3 in e) \"default\" !== _t3 && {}.hasOwnProperty.call(e, _t3) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t3)) && (i.get || i.set) ? o(f, _t3, i) : f[_t3] = e[_t3]); return f; })(e, t); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _wrapNativeSuper(t) { var r = \"function\" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }\nfunction _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf(\"[native code]\"); } catch (n) { return \"function\" == typeof t; } }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = \"function\" == typeof Symbol ? Symbol : {}, n = r.iterator || \"@@iterator\", o = r.toStringTag || \"@@toStringTag\"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, \"_invoke\", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError(\"Generator is already running\"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = \"next\"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError(\"iterator result is not an object\"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i[\"return\"]) && t.call(i), c < 2 && (u = TypeError(\"The iterator does not provide a '\" + o + \"' method\"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, \"GeneratorFunction\")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, \"constructor\", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = \"GeneratorFunction\", _regeneratorDefine2(GeneratorFunctionPrototype, o, \"GeneratorFunction\"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, \"Generator\"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, \"toString\", function () { return \"[object Generator]\"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }\nfunction _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, \"\", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o(\"next\", 0), o(\"throw\", 1), o(\"return\", 2); } }, _regeneratorDefine2(e, r, n, t); }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; } /**\n * Copyright 2018 Google LLC\n *\n * Distributed under MIT license.\n * See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n */\nvar readFile = fs.readFile ? (0, _util.promisify)(fs.readFile) : /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {\n  return _regenerator().w(function (_context) {\n    while (1) switch (_context.n) {\n      case 0:\n        throw new ErrorWithCode('use key rather than keyFile.', 'MISSING_CREDENTIALS');\n      case 1:\n        return _context.a(2);\n    }\n  }, _callee);\n}));\nvar GOOGLE_TOKEN_URL = 'https://oauth2.googleapis.com/token';\nvar GOOGLE_REVOKE_TOKEN_URL = 'https://oauth2.googleapis.com/revoke?token=';\nvar ErrorWithCode = /*#__PURE__*/function (_Error) {\n  function ErrorWithCode(message, code) {\n    var _this;\n    _classCallCheck(this, ErrorWithCode);\n    _this = _callSuper(this, ErrorWithCode, [message]);\n    _defineProperty(_this, \"code\", void 0);\n    _this.code = code;\n    return _this;\n  }\n  _inherits(ErrorWithCode, _Error);\n  return _createClass(ErrorWithCode);\n}(/*#__PURE__*/_wrapNativeSuper(Error));\nvar _inFlightRequest = /*#__PURE__*/new WeakMap();\nvar _GoogleToken_brand = /*#__PURE__*/new WeakSet();\nvar GoogleToken = exports.GoogleToken = /*#__PURE__*/function () {\n  /**\n   * Create a GoogleToken.\n   *\n   * @param options  Configuration object.\n   */\n  function GoogleToken(_options) {\n    _classCallCheck(this, GoogleToken);\n    _classPrivateMethodInitSpec(this, _GoogleToken_brand);\n    _defineProperty(this, \"expiresAt\", void 0);\n    _defineProperty(this, \"key\", void 0);\n    _defineProperty(this, \"keyFile\", void 0);\n    _defineProperty(this, \"iss\", void 0);\n    _defineProperty(this, \"sub\", void 0);\n    _defineProperty(this, \"scope\", void 0);\n    _defineProperty(this, \"rawToken\", void 0);\n    _defineProperty(this, \"tokenExpires\", void 0);\n    _defineProperty(this, \"email\", void 0);\n    _defineProperty(this, \"additionalClaims\", void 0);\n    _defineProperty(this, \"eagerRefreshThresholdMillis\", void 0);\n    _defineProperty(this, \"transporter\", {\n      request: function request(opts) {\n        return (0, _gaxios.request)(opts);\n      }\n    });\n    _classPrivateFieldInitSpec(this, _inFlightRequest, void 0);\n    _assertClassBrand(_GoogleToken_brand, this, _configure).call(this, _options);\n  }\n\n  /**\n   * Returns whether the token has expired.\n   *\n   * @return true if the token has expired, false otherwise.\n   */\n  return _createClass(GoogleToken, [{\n    key: \"accessToken\",\n    get: function get() {\n      return this.rawToken ? this.rawToken.access_token : undefined;\n    }\n  }, {\n    key: \"idToken\",\n    get: function get() {\n      return this.rawToken ? this.rawToken.id_token : undefined;\n    }\n  }, {\n    key: \"tokenType\",\n    get: function get() {\n      return this.rawToken ? this.rawToken.token_type : undefined;\n    }\n  }, {\n    key: \"refreshToken\",\n    get: function get() {\n      return this.rawToken ? this.rawToken.refresh_token : undefined;\n    }\n  }, {\n    key: \"hasExpired\",\n    value: function hasExpired() {\n      var now = new Date().getTime();\n      if (this.rawToken && this.expiresAt) {\n        return now >= this.expiresAt;\n      } else {\n        return true;\n      }\n    }\n\n    /**\n     * Returns whether the token will expire within eagerRefreshThresholdMillis\n     *\n     * @return true if the token will be expired within eagerRefreshThresholdMillis, false otherwise.\n     */\n  }, {\n    key: \"isTokenExpiring\",\n    value: function isTokenExpiring() {\n      var _this$eagerRefreshThr;\n      var now = new Date().getTime();\n      var eagerRefreshThresholdMillis = (_this$eagerRefreshThr = this.eagerRefreshThresholdMillis) !== null && _this$eagerRefreshThr !== void 0 ? _this$eagerRefreshThr : 0;\n      if (this.rawToken && this.expiresAt) {\n        return this.expiresAt <= now + eagerRefreshThresholdMillis;\n      } else {\n        return true;\n      }\n    }\n\n    /**\n     * Returns a cached token or retrieves a new one from Google.\n     *\n     * @param callback The callback function.\n     */\n  }, {\n    key: \"getToken\",\n    value: function getToken(callback) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (_typeof(callback) === 'object') {\n        opts = callback;\n        callback = undefined;\n      }\n      opts = Object.assign({\n        forceRefresh: false\n      }, opts);\n      if (callback) {\n        var cb = callback;\n        _assertClassBrand(_GoogleToken_brand, this, _getTokenAsync).call(this, opts).then(function (t) {\n          return cb(null, t);\n        }, callback);\n        return;\n      }\n      return _assertClassBrand(_GoogleToken_brand, this, _getTokenAsync).call(this, opts);\n    }\n\n    /**\n     * Given a keyFile, extract the key and client email if available\n     * @param keyFile Path to a json, pem, or p12 file that contains the key.\n     * @returns an object with privateKey and clientEmail properties\n     */\n  }, {\n    key: \"getCredentials\",\n    value: (function () {\n      var _getCredentials = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(keyFile) {\n        var ext, key, body, privateKey, clientEmail, _privateKey, _t;\n        return _regenerator().w(function (_context2) {\n          while (1) switch (_context2.n) {\n            case 0:\n              ext = path.extname(keyFile);\n              _t = ext;\n              _context2.n = _t === '.json' ? 1 : _t === '.der' ? 4 : _t === '.crt' ? 4 : _t === '.pem' ? 4 : _t === '.p12' ? 6 : _t === '.pfx' ? 6 : 7;\n              break;\n            case 1:\n              _context2.n = 2;\n              return readFile(keyFile, 'utf8');\n            case 2:\n              key = _context2.v;\n              body = JSON.parse(key);\n              privateKey = body.private_key;\n              clientEmail = body.client_email;\n              if (!(!privateKey || !clientEmail)) {\n                _context2.n = 3;\n                break;\n              }\n              throw new ErrorWithCode('private_key and client_email are required.', 'MISSING_CREDENTIALS');\n            case 3:\n              return _context2.a(2, {\n                privateKey: privateKey,\n                clientEmail: clientEmail\n              });\n            case 4:\n              _context2.n = 5;\n              return readFile(keyFile, 'utf8');\n            case 5:\n              _privateKey = _context2.v;\n              return _context2.a(2, {\n                privateKey: _privateKey\n              });\n            case 6:\n              throw new ErrorWithCode('*.p12 certificates are not supported after v6.1.2. ' + 'Consider utilizing *.json format or converting *.p12 to *.pem using the OpenSSL CLI.', 'UNKNOWN_CERTIFICATE_TYPE');\n            case 7:\n              throw new ErrorWithCode('Unknown certificate type. Type is determined based on file extension. ' + 'Current supported extensions are *.json, and *.pem.', 'UNKNOWN_CERTIFICATE_TYPE');\n            case 8:\n              return _context2.a(2);\n          }\n        }, _callee2);\n      }));\n      function getCredentials(_x) {\n        return _getCredentials.apply(this, arguments);\n      }\n      return getCredentials;\n    }())\n  }, {\n    key: \"revokeToken\",\n    value: function revokeToken(callback) {\n      if (callback) {\n        _assertClassBrand(_GoogleToken_brand, this, _revokeTokenAsync).call(this).then(function () {\n          return callback();\n        }, callback);\n        return;\n      }\n      return _assertClassBrand(_GoogleToken_brand, this, _revokeTokenAsync).call(this);\n    }\n  }]);\n}();\nfunction _getTokenAsync(_x2) {\n  return _getTokenAsync2.apply(this, arguments);\n}\nfunction _getTokenAsync2() {\n  _getTokenAsync2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(opts) {\n    return _regenerator().w(function (_context3) {\n      while (1) switch (_context3.n) {\n        case 0:\n          if (!(_classPrivateFieldGet(_inFlightRequest, this) && !opts.forceRefresh)) {\n            _context3.n = 1;\n            break;\n          }\n          return _context3.a(2, _classPrivateFieldGet(_inFlightRequest, this));\n        case 1:\n          _context3.p = 1;\n          _context3.n = 2;\n          return _classPrivateFieldSet(_inFlightRequest, this, _assertClassBrand(_GoogleToken_brand, this, _getTokenAsyncInner).call(this, opts));\n        case 2:\n          return _context3.a(2, _context3.v);\n        case 3:\n          _context3.p = 3;\n          _classPrivateFieldSet(_inFlightRequest, this, undefined);\n          return _context3.f(3);\n        case 4:\n          return _context3.a(2);\n      }\n    }, _callee3, this, [[1,, 3, 4]]);\n  }));\n  return _getTokenAsync2.apply(this, arguments);\n}\nfunction _getTokenAsyncInner(_x3) {\n  return _getTokenAsyncInner2.apply(this, arguments);\n}\nfunction _getTokenAsyncInner2() {\n  _getTokenAsyncInner2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(opts) {\n    var creds;\n    return _regenerator().w(function (_context4) {\n      while (1) switch (_context4.n) {\n        case 0:\n          if (!(this.isTokenExpiring() === false && opts.forceRefresh === false)) {\n            _context4.n = 1;\n            break;\n          }\n          return _context4.a(2, Promise.resolve(this.rawToken));\n        case 1:\n          if (!(!this.key && !this.keyFile)) {\n            _context4.n = 2;\n            break;\n          }\n          throw new Error('No key or keyFile set.');\n        case 2:\n          if (!(!this.key && this.keyFile)) {\n            _context4.n = 4;\n            break;\n          }\n          _context4.n = 3;\n          return this.getCredentials(this.keyFile);\n        case 3:\n          creds = _context4.v;\n          this.key = creds.privateKey;\n          this.iss = creds.clientEmail || this.iss;\n          if (!creds.clientEmail) {\n            _assertClassBrand(_GoogleToken_brand, this, _ensureEmail).call(this);\n          }\n        case 4:\n          return _context4.a(2, _assertClassBrand(_GoogleToken_brand, this, _requestToken).call(this));\n      }\n    }, _callee4, this);\n  }));\n  return _getTokenAsyncInner2.apply(this, arguments);\n}\nfunction _ensureEmail() {\n  if (!this.iss) {\n    throw new ErrorWithCode('email is required.', 'MISSING_CREDENTIALS');\n  }\n}\nfunction _revokeTokenAsync() {\n  return _revokeTokenAsync2.apply(this, arguments);\n}\nfunction _revokeTokenAsync2() {\n  _revokeTokenAsync2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {\n    var url;\n    return _regenerator().w(function (_context5) {\n      while (1) switch (_context5.n) {\n        case 0:\n          if (this.accessToken) {\n            _context5.n = 1;\n            break;\n          }\n          throw new Error('No token to revoke.');\n        case 1:\n          url = GOOGLE_REVOKE_TOKEN_URL + this.accessToken;\n          _context5.n = 2;\n          return this.transporter.request({\n            url: url,\n            retry: true\n          });\n        case 2:\n          _assertClassBrand(_GoogleToken_brand, this, _configure).call(this, {\n            email: this.iss,\n            sub: this.sub,\n            key: this.key,\n            keyFile: this.keyFile,\n            scope: this.scope,\n            additionalClaims: this.additionalClaims\n          });\n        case 3:\n          return _context5.a(2);\n      }\n    }, _callee5, this);\n  }));\n  return _revokeTokenAsync2.apply(this, arguments);\n}\n/**\n * Configure the GoogleToken for re-use.\n * @param  {object} options Configuration object.\n */\nfunction _configure() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  this.keyFile = options.keyFile;\n  this.key = options.key;\n  this.rawToken = undefined;\n  this.iss = options.email || options.iss;\n  this.sub = options.sub;\n  this.additionalClaims = options.additionalClaims;\n  if (_typeof(options.scope) === 'object') {\n    this.scope = options.scope.join(' ');\n  } else {\n    this.scope = options.scope;\n  }\n  this.eagerRefreshThresholdMillis = options.eagerRefreshThresholdMillis;\n  if (options.transporter) {\n    this.transporter = options.transporter;\n  }\n}\n/**\n * Request the token from Google.\n */\nfunction _requestToken() {\n  return _requestToken2.apply(this, arguments);\n}\nfunction _requestToken2() {\n  _requestToken2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6() {\n    var iat, additionalClaims, payload, signedJWT, r, _response, _response2, body, desc, _t2;\n    return _regenerator().w(function (_context6) {\n      while (1) switch (_context6.n) {\n        case 0:\n          iat = Math.floor(new Date().getTime() / 1000);\n          additionalClaims = this.additionalClaims || {};\n          payload = Object.assign({\n            iss: this.iss,\n            scope: this.scope,\n            aud: GOOGLE_TOKEN_URL,\n            exp: iat + 3600,\n            iat: iat,\n            sub: this.sub\n          }, additionalClaims);\n          signedJWT = jws.sign({\n            header: {\n              alg: 'RS256'\n            },\n            payload: payload,\n            secret: this.key\n          });\n          _context6.p = 1;\n          _context6.n = 2;\n          return this.transporter.request({\n            method: 'POST',\n            url: GOOGLE_TOKEN_URL,\n            data: new URLSearchParams({\n              grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n              assertion: signedJWT\n            }),\n            responseType: 'json',\n            retryConfig: {\n              httpMethodsToRetry: ['POST']\n            }\n          });\n        case 2:\n          r = _context6.v;\n          this.rawToken = r.data;\n          this.expiresAt = r.data.expires_in === null || r.data.expires_in === undefined ? undefined : (iat + r.data.expires_in) * 1000;\n          return _context6.a(2, this.rawToken);\n        case 3:\n          _context6.p = 3;\n          _t2 = _context6.v;\n          this.rawToken = undefined;\n          this.tokenExpires = undefined;\n          body = _t2.response && (_response = _t2.response) !== null && _response !== void 0 && _response.data ? (_response2 = _t2.response) === null || _response2 === void 0 ? void 0 : _response2.data : {};\n          if (body.error) {\n            desc = body.error_description ? \": \".concat(body.error_description) : '';\n            _t2.message = \"\".concat(body.error).concat(desc);\n          }\n          throw _t2;\n        case 4:\n          return _context6.a(2);\n      }\n    }, _callee6, this, [[1, 3]]);\n  }));\n  return _requestToken2.apply(this, arguments);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ3Rva2VuL2J1aWxkL2Nqcy9zcmMvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLG1CQUFtQjtBQUNuQixpQ0FBaUMsbUJBQU8sQ0FBQyxjQUFJO0FBQzdDLGNBQWMsbUJBQU8sQ0FBQyxrRUFBUTtBQUM5QixrQ0FBa0MsbUJBQU8sQ0FBQyw4Q0FBSztBQUMvQyxtQ0FBbUMsbUJBQU8sQ0FBQyxrQkFBTTtBQUNqRCxZQUFZLG1CQUFPLENBQUMsa0JBQU07QUFDMUIseUNBQXlDLDRFQUE0RSwyRUFBMkUsdUNBQXVDLGdCQUFnQixpQ0FBaUMsOEVBQThFLHFCQUFxQiwrQkFBK0IsZUFBZSwwQ0FBMEMscUtBQXFLLFdBQVc7QUFDbm9CLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLDZDQUE2QztBQUM3QywrQ0FBK0M7QUFDL0MsNENBQTRDO0FBQzVDLDBDQUEwQztBQUMxQyx1Q0FBdUM7QUFDdkMsc0NBQXNDLHNGQUFzRjtBQUM1SCxtQ0FBbUMsZ0JBQWdCLGNBQWMsT0FBTyxjQUFjO0FBQ3RGLGlDQUFpQyxxSEFBcUgsY0FBYztBQUNwSyxpQ0FBaUM7QUFDakMsK0JBQStCO0FBQy9CLDRDQUE0Qyx1RUFBdUUsbUdBQW1HO0FBQ3ROLHFDQUFxQyx5R0FBeUc7QUFDOUksMkJBQTJCLHFIQUFxSCxnREFBZ0QsZUFBZSw0Q0FBNEMsMkNBQTJDLGNBQWM7QUFDcFQsK0JBQStCLHVEQUF1RCx5REFBeUQsbURBQW1ELHVHQUF1RyxvQkFBb0IsK0JBQStCLHFCQUFxQixxQkFBcUIsc0VBQXNFLHdEQUF3RCxlQUFlLGtFQUFrRSxpQ0FBaUM7QUFDdG5CLCtCQUErQixrRkFBa0YsZ0JBQWdCLG9CQUFvQixvQ0FBb0M7QUFDekwsdUNBQXVDLE1BQU0scUZBQXFGLE1BQU0sYUFBYSwyRUFBMkUsYUFBYTtBQUM3TyxnQ0FBZ0MsTUFBTSxvRUFBb0UsWUFBWTtBQUN0SCxpQ0FBaUMsa0dBQWtHLDRCQUE0QjtBQUMvSiw4QkFBOEIsK0ZBQStGLGlEQUFpRDtBQUM5SyxvQ0FBb0Msb0VBQW9FLDBEQUEwRDtBQUNsSyw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4Qiw0Q0FBNEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsc0NBQXNDLHVFQUF1RTtBQUM3USwwQkFBMEIsME5BQTBOLHdFQUF3RSx5QkFBeUIsK0ZBQStGLDhEQUE4RCwrQ0FBK0MsK0RBQStELDZDQUE2QyxtQkFBbUIsMEJBQTBCLCtCQUErQixPQUFPLG9DQUFvQyw4T0FBOE8sMEJBQTBCLG1CQUFtQiw0QkFBNEIsNERBQTRELDRDQUE0QywwQkFBMEIsSUFBSSx1RUFBdUUsTUFBTSxnQkFBZ0IsbUNBQW1DLDhFQUE4RSx1QkFBdUIsaUNBQWlDLHVJQUF1SSxTQUFTLGdFQUFnRSxZQUFZLHVCQUF1QixVQUFVLFdBQVcsU0FBUyx5QkFBeUIscUJBQXFCLFlBQVksd0JBQXdCLGdDQUFnQyx5Q0FBeUMsMkJBQTJCLDJEQUEyRCxtQkFBbUIsY0FBYywwRkFBMEYsZ0JBQWdCLHVOQUF1Tiw2YkFBNmIsY0FBYyxvREFBb0QsOEJBQThCLDZDQUE2QyxTQUFTLGVBQWU7QUFDNzRGLDJDQUEyQywrQkFBK0IsTUFBTSxJQUFJLFFBQVEsS0FBSyxZQUFZLFNBQVMsZ0VBQWdFLHFCQUFxQiwwREFBMEQsYUFBYSxPQUFPLDJCQUEyQix5Q0FBeUMsK0JBQStCLE1BQU0sZ0RBQWdEO0FBQ2xiLG1EQUFtRCxNQUFNLGdDQUFnQyxZQUFZLG9CQUFvQjtBQUN6SCxnQ0FBZ0MscUJBQXFCLDZCQUE2QixxQ0FBcUMsdUJBQXVCLG9CQUFvQix5REFBeUQscUJBQXFCLDBEQUEwRCxnQkFBZ0IsUUFBUTtBQUNsVTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL2d0b2tlbi9idWlsZC9janMvc3JjL2luZGV4LmNqcz82MWIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Hb29nbGVUb2tlbiA9IHZvaWQgMDtcbnZhciBmcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJmc1wiKSk7XG52YXIgX2dheGlvcyA9IHJlcXVpcmUoXCJnYXhpb3NcIik7XG52YXIgandzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcImp3c1wiKSk7XG52YXIgcGF0aCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJwYXRoXCIpKTtcbnZhciBfdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgdCkgeyBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBXZWFrTWFwKSB2YXIgciA9IG5ldyBXZWFrTWFwKCksIG4gPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkID0gZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgdCkgeyBpZiAoIXQgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyB2YXIgbywgaSwgZiA9IHsgX19wcm90b19fOiBudWxsLCBcImRlZmF1bHRcIjogZSB9OyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IF90eXBlb2YoZSkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4gZjsgaWYgKG8gPSB0ID8gbiA6IHIpIHsgaWYgKG8uaGFzKGUpKSByZXR1cm4gby5nZXQoZSk7IG8uc2V0KGUsIGYpOyB9IGZvciAodmFyIF90MyBpbiBlKSBcImRlZmF1bHRcIiAhPT0gX3QzICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgX3QzKSAmJiAoKGkgPSAobyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBfdDMpKSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gbyhmLCBfdDMsIGkpIDogZltfdDNdID0gZVtfdDNdKTsgcmV0dXJuIGY7IH0pKGUsIHQpOyB9XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfY2xhc3NQcml2YXRlTWV0aG9kSW5pdFNwZWMoZSwgYSkgeyBfY2hlY2tQcml2YXRlUmVkZWNsYXJhdGlvbihlLCBhKSwgYS5hZGQoZSk7IH1cbmZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjKGUsIHQsIGEpIHsgX2NoZWNrUHJpdmF0ZVJlZGVjbGFyYXRpb24oZSwgdCksIHQuc2V0KGUsIGEpOyB9XG5mdW5jdGlvbiBfY2hlY2tQcml2YXRlUmVkZWNsYXJhdGlvbihlLCB0KSB7IGlmICh0LmhhcyhlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBpbml0aWFsaXplIHRoZSBzYW1lIHByaXZhdGUgZWxlbWVudHMgdHdpY2Ugb24gYW4gb2JqZWN0XCIpOyB9XG5mdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRTZXQocywgYSwgcikgeyByZXR1cm4gcy5zZXQoX2Fzc2VydENsYXNzQnJhbmQocywgYSksIHIpLCByOyB9XG5mdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRHZXQocywgYSkgeyByZXR1cm4gcy5nZXQoX2Fzc2VydENsYXNzQnJhbmQocywgYSkpOyB9XG5mdW5jdGlvbiBfYXNzZXJ0Q2xhc3NCcmFuZChlLCB0LCBuKSB7IGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUgPyBlID09PSB0IDogZS5oYXModCkpIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHQgOiBuOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBlbGVtZW50IGlzIG5vdCBwcmVzZW50IG9uIHRoaXMgb2JqZWN0XCIpOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7IGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykgeyB2YXIgbyA9IHJbdF07IG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikgeyBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH1cbmZ1bmN0aW9uIF9jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBlKSB7IGlmIChlICYmIChcIm9iamVjdFwiID09IF90eXBlb2YoZSkgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlKSkgcmV0dXJuIGU7IGlmICh2b2lkIDAgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQodCk7IH1cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoZSkgeyBpZiAodm9pZCAwID09PSBlKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfaW5oZXJpdHModCwgZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlICYmIG51bGwgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHQsIHdyaXRhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCB9IH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGUgJiYgX3NldFByb3RvdHlwZU9mKHQsIGUpOyB9XG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKHQpIHsgdmFyIHIgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIE1hcCA/IG5ldyBNYXAoKSA6IHZvaWQgMDsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKHQpIHsgaWYgKG51bGwgPT09IHQgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKHQpKSByZXR1cm4gdDsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyBpZiAodm9pZCAwICE9PSByKSB7IGlmIChyLmhhcyh0KSkgcmV0dXJuIHIuZ2V0KHQpOyByLnNldCh0LCBXcmFwcGVyKTsgfSBmdW5jdGlvbiBXcmFwcGVyKCkgeyByZXR1cm4gX2NvbnN0cnVjdCh0LCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7IH0gcmV0dXJuIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0LnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogV3JhcHBlciwgZW51bWVyYWJsZTogITEsIHdyaXRhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCB9IH0pLCBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgdCk7IH0sIF93cmFwTmF0aXZlU3VwZXIodCk7IH1cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QodCwgZSwgcikgeyBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSByZXR1cm4gUmVmbGVjdC5jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgdmFyIG8gPSBbbnVsbF07IG8ucHVzaC5hcHBseShvLCBlKTsgdmFyIHAgPSBuZXcgKHQuYmluZC5hcHBseSh0LCBvKSkoKTsgcmV0dXJuIHIgJiYgX3NldFByb3RvdHlwZU9mKHAsIHIucHJvdG90eXBlKSwgcDsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbih0KSB7IHRyeSB7IHJldHVybiAtMSAhPT0gRnVuY3Rpb24udG9TdHJpbmcuY2FsbCh0KS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKTsgfSBjYXRjaCAobikgeyByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiB0OyB9IH1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZih0LCBlKSB7IHJldHVybiBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQsIGUpIHsgcmV0dXJuIHQuX19wcm90b19fID0gZSwgdDsgfSwgX3NldFByb3RvdHlwZU9mKHQsIGUpOyB9XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YodCkgeyByZXR1cm4gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7IH0sIF9nZXRQcm90b3R5cGVPZih0KTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gX3JlZ2VuZXJhdG9yKCkgeyAvKiEgcmVnZW5lcmF0b3ItcnVudGltZSAtLSBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy4gLS0gbGljZW5zZSAoTUlUKTogaHR0cHM6Ly9naXRodWIuY29tL2JhYmVsL2JhYmVsL2Jsb2IvbWFpbi9wYWNrYWdlcy9iYWJlbC1oZWxwZXJzL0xJQ0VOU0UgKi8gdmFyIGUsIHQsIHIgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCA/IFN5bWJvbCA6IHt9LCBuID0gci5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIiwgbyA9IHIudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7IGZ1bmN0aW9uIGkociwgbiwgbywgaSkgeyB2YXIgYyA9IG4gJiYgbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBuIDogR2VuZXJhdG9yLCB1ID0gT2JqZWN0LmNyZWF0ZShjLnByb3RvdHlwZSk7IHJldHVybiBfcmVnZW5lcmF0b3JEZWZpbmUyKHUsIFwiX2ludm9rZVwiLCBmdW5jdGlvbiAociwgbiwgbykgeyB2YXIgaSwgYywgdSwgZiA9IDAsIHAgPSBvIHx8IFtdLCB5ID0gITEsIEcgPSB7IHA6IDAsIG46IDAsIHY6IGUsIGE6IGQsIGY6IGQuYmluZChlLCA0KSwgZDogZnVuY3Rpb24gZCh0LCByKSB7IHJldHVybiBpID0gdCwgYyA9IDAsIHUgPSBlLCBHLm4gPSByLCBhOyB9IH07IGZ1bmN0aW9uIGQociwgbikgeyBmb3IgKGMgPSByLCB1ID0gbiwgdCA9IDA7ICF5ICYmIGYgJiYgIW8gJiYgdCA8IHAubGVuZ3RoOyB0KyspIHsgdmFyIG8sIGkgPSBwW3RdLCBkID0gRy5wLCBsID0gaVsyXTsgciA+IDMgPyAobyA9IGwgPT09IG4pICYmICh1ID0gaVsoYyA9IGlbNF0pID8gNSA6IChjID0gMywgMyldLCBpWzRdID0gaVs1XSA9IGUpIDogaVswXSA8PSBkICYmICgobyA9IHIgPCAyICYmIGQgPCBpWzFdKSA/IChjID0gMCwgRy52ID0gbiwgRy5uID0gaVsxXSkgOiBkIDwgbCAmJiAobyA9IHIgPCAzIHx8IGlbMF0gPiBuIHx8IG4gPiBsKSAmJiAoaVs0XSA9IHIsIGlbNV0gPSBuLCBHLm4gPSBsLCBjID0gMCkpOyB9IGlmIChvIHx8IHIgPiAxKSByZXR1cm4gYTsgdGhyb3cgeSA9ICEwLCBuOyB9IHJldHVybiBmdW5jdGlvbiAobywgcCwgbCkgeyBpZiAoZiA+IDEpIHRocm93IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7IGZvciAoeSAmJiAxID09PSBwICYmIGQocCwgbCksIGMgPSBwLCB1ID0gbDsgKHQgPSBjIDwgMiA/IGUgOiB1KSB8fCAheTspIHsgaSB8fCAoYyA/IGMgPCAzID8gKGMgPiAxICYmIChHLm4gPSAtMSksIGQoYywgdSkpIDogRy5uID0gdSA6IEcudiA9IHUpOyB0cnkgeyBpZiAoZiA9IDIsIGkpIHsgaWYgKGMgfHwgKG8gPSBcIm5leHRcIiksIHQgPSBpW29dKSB7IGlmICghKHQgPSB0LmNhbGwoaSwgdSkpKSB0aHJvdyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTsgaWYgKCF0LmRvbmUpIHJldHVybiB0OyB1ID0gdC52YWx1ZSwgYyA8IDIgJiYgKGMgPSAwKTsgfSBlbHNlIDEgPT09IGMgJiYgKHQgPSBpW1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoaSksIGMgPCAyICYmICh1ID0gVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAnXCIgKyBvICsgXCInIG1ldGhvZFwiKSwgYyA9IDEpOyBpID0gZTsgfSBlbHNlIGlmICgodCA9ICh5ID0gRy5uIDwgMCkgPyB1IDogci5jYWxsKG4sIEcpKSAhPT0gYSkgYnJlYWs7IH0gY2F0Y2ggKHQpIHsgaSA9IGUsIGMgPSAxLCB1ID0gdDsgfSBmaW5hbGx5IHsgZiA9IDE7IH0gfSByZXR1cm4geyB2YWx1ZTogdCwgZG9uZTogeSB9OyB9OyB9KHIsIG8sIGkpLCAhMCksIHU7IH0gdmFyIGEgPSB7fTsgZnVuY3Rpb24gR2VuZXJhdG9yKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fSBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9IHQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7IHZhciBjID0gW11bbl0gPyB0KHQoW11bbl0oKSkpIDogKF9yZWdlbmVyYXRvckRlZmluZTIodCA9IHt9LCBuLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgdCksIHUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjKTsgZnVuY3Rpb24gZihlKSB7IHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YoZSwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpIDogKGUuX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIF9yZWdlbmVyYXRvckRlZmluZTIoZSwgbywgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksIGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh1KSwgZTsgfSByZXR1cm4gR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIF9yZWdlbmVyYXRvckRlZmluZTIodSwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSksIF9yZWdlbmVyYXRvckRlZmluZTIoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb24pLCBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiwgX3JlZ2VuZXJhdG9yRGVmaW5lMihHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgbywgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSwgX3JlZ2VuZXJhdG9yRGVmaW5lMih1KSwgX3JlZ2VuZXJhdG9yRGVmaW5lMih1LCBvLCBcIkdlbmVyYXRvclwiKSwgX3JlZ2VuZXJhdG9yRGVmaW5lMih1LCBuLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgX3JlZ2VuZXJhdG9yRGVmaW5lMih1LCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7IH0pLCAoX3JlZ2VuZXJhdG9yID0gZnVuY3Rpb24gX3JlZ2VuZXJhdG9yKCkgeyByZXR1cm4geyB3OiBpLCBtOiBmIH07IH0pKCk7IH1cbmZ1bmN0aW9uIF9yZWdlbmVyYXRvckRlZmluZTIoZSwgciwgbiwgdCkgeyB2YXIgaSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTsgdHJ5IHsgaSh7fSwgXCJcIiwge30pOyB9IGNhdGNoIChlKSB7IGkgPSAwOyB9IF9yZWdlbmVyYXRvckRlZmluZTIgPSBmdW5jdGlvbiBfcmVnZW5lcmF0b3JEZWZpbmUoZSwgciwgbiwgdCkgeyBpZiAocikgaSA/IGkoZSwgciwgeyB2YWx1ZTogbiwgZW51bWVyYWJsZTogIXQsIGNvbmZpZ3VyYWJsZTogIXQsIHdyaXRhYmxlOiAhdCB9KSA6IGVbcl0gPSBuO2Vsc2UgeyB2YXIgbyA9IGZ1bmN0aW9uIG8ociwgbikgeyBfcmVnZW5lcmF0b3JEZWZpbmUyKGUsIHIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiB0aGlzLl9pbnZva2UociwgbiwgZSk7IH0pOyB9OyBvKFwibmV4dFwiLCAwKSwgbyhcInRocm93XCIsIDEpLCBvKFwicmV0dXJuXCIsIDIpOyB9IH0sIF9yZWdlbmVyYXRvckRlZmluZTIoZSwgciwgbiwgdCk7IH1cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChuLCB0LCBlLCByLCBvLCBhLCBjKSB7IHRyeSB7IHZhciBpID0gblthXShjKSwgdSA9IGkudmFsdWU7IH0gY2F0Y2ggKG4pIHsgcmV0dXJuIHZvaWQgZShuKTsgfSBpLmRvbmUgPyB0KHUpIDogUHJvbWlzZS5yZXNvbHZlKHUpLnRoZW4ociwgbyk7IH1cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIHQgPSB0aGlzLCBlID0gYXJndW1lbnRzOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHIsIG8pIHsgdmFyIGEgPSBuLmFwcGx5KHQsIGUpOyBmdW5jdGlvbiBfbmV4dChuKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChhLCByLCBvLCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgbik7IH0gZnVuY3Rpb24gX3Rocm93KG4pIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGEsIHIsIG8sIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgbik7IH0gX25leHQodm9pZCAwKTsgfSk7IH07IH0gLyoqXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogRGlzdHJpYnV0ZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBTZWUgZmlsZSBMSUNFTlNFIGZvciBkZXRhaWwgb3IgY29weSBhdCBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICovXG52YXIgcmVhZEZpbGUgPSBmcy5yZWFkRmlsZSA/ICgwLCBfdXRpbC5wcm9taXNpZnkpKGZzLnJlYWRGaWxlKSA6IC8qI19fUFVSRV9fKi9fYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yKCkubShmdW5jdGlvbiBfY2FsbGVlKCkge1xuICByZXR1cm4gX3JlZ2VuZXJhdG9yKCkudyhmdW5jdGlvbiAoX2NvbnRleHQpIHtcbiAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcldpdGhDb2RlKCd1c2Uga2V5IHJhdGhlciB0aGFuIGtleUZpbGUuJywgJ01JU1NJTkdfQ1JFREVOVElBTFMnKTtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIF9jb250ZXh0LmEoMik7XG4gICAgfVxuICB9LCBfY2FsbGVlKTtcbn0pKTtcbnZhciBHT09HTEVfVE9LRU5fVVJMID0gJ2h0dHBzOi8vb2F1dGgyLmdvb2dsZWFwaXMuY29tL3Rva2VuJztcbnZhciBHT09HTEVfUkVWT0tFX1RPS0VOX1VSTCA9ICdodHRwczovL29hdXRoMi5nb29nbGVhcGlzLmNvbS9yZXZva2U/dG9rZW49JztcbnZhciBFcnJvcldpdGhDb2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgZnVuY3Rpb24gRXJyb3JXaXRoQ29kZShtZXNzYWdlLCBjb2RlKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFcnJvcldpdGhDb2RlKTtcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgRXJyb3JXaXRoQ29kZSwgW21lc3NhZ2VdKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiY29kZVwiLCB2b2lkIDApO1xuICAgIF90aGlzLmNvZGUgPSBjb2RlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoRXJyb3JXaXRoQ29kZSwgX0Vycm9yKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFcnJvcldpdGhDb2RlKTtcbn0oLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcbnZhciBfaW5GbGlnaHRSZXF1ZXN0ID0gLyojX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG52YXIgX0dvb2dsZVRva2VuX2JyYW5kID0gLyojX19QVVJFX18qL25ldyBXZWFrU2V0KCk7XG52YXIgR29vZ2xlVG9rZW4gPSBleHBvcnRzLkdvb2dsZVRva2VuID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIEdvb2dsZVRva2VuLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAgQ29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBHb29nbGVUb2tlbihfb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHb29nbGVUb2tlbik7XG4gICAgX2NsYXNzUHJpdmF0ZU1ldGhvZEluaXRTcGVjKHRoaXMsIF9Hb29nbGVUb2tlbl9icmFuZCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhwaXJlc0F0XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwia2V5XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwia2V5RmlsZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlzc1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN1YlwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNjb3BlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmF3VG9rZW5cIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b2tlbkV4cGlyZXNcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbWFpbFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFkZGl0aW9uYWxDbGFpbXNcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXNcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFuc3BvcnRlclwiLCB7XG4gICAgICByZXF1ZXN0OiBmdW5jdGlvbiByZXF1ZXN0KG9wdHMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBfZ2F4aW9zLnJlcXVlc3QpKG9wdHMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjKHRoaXMsIF9pbkZsaWdodFJlcXVlc3QsIHZvaWQgMCk7XG4gICAgX2Fzc2VydENsYXNzQnJhbmQoX0dvb2dsZVRva2VuX2JyYW5kLCB0aGlzLCBfY29uZmlndXJlKS5jYWxsKHRoaXMsIF9vcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHRva2VuIGhhcyBleHBpcmVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgdGhlIHRva2VuIGhhcyBleHBpcmVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEdvb2dsZVRva2VuLCBbe1xuICAgIGtleTogXCJhY2Nlc3NUb2tlblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucmF3VG9rZW4gPyB0aGlzLnJhd1Rva2VuLmFjY2Vzc190b2tlbiA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaWRUb2tlblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucmF3VG9rZW4gPyB0aGlzLnJhd1Rva2VuLmlkX3Rva2VuIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b2tlblR5cGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJhd1Rva2VuID8gdGhpcy5yYXdUb2tlbi50b2tlbl90eXBlIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWZyZXNoVG9rZW5cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJhd1Rva2VuID8gdGhpcy5yYXdUb2tlbi5yZWZyZXNoX3Rva2VuIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNFeHBpcmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0V4cGlyZWQoKSB7XG4gICAgICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICBpZiAodGhpcy5yYXdUb2tlbiAmJiB0aGlzLmV4cGlyZXNBdCkge1xuICAgICAgICByZXR1cm4gbm93ID49IHRoaXMuZXhwaXJlc0F0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSB0b2tlbiB3aWxsIGV4cGlyZSB3aXRoaW4gZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRydWUgaWYgdGhlIHRva2VuIHdpbGwgYmUgZXhwaXJlZCB3aXRoaW4gZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNUb2tlbkV4cGlyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzVG9rZW5FeHBpcmluZygpIHtcbiAgICAgIHZhciBfdGhpcyRlYWdlclJlZnJlc2hUaHI7XG4gICAgICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICB2YXIgZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzID0gKF90aGlzJGVhZ2VyUmVmcmVzaFRociA9IHRoaXMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzKSAhPT0gbnVsbCAmJiBfdGhpcyRlYWdlclJlZnJlc2hUaHIgIT09IHZvaWQgMCA/IF90aGlzJGVhZ2VyUmVmcmVzaFRociA6IDA7XG4gICAgICBpZiAodGhpcy5yYXdUb2tlbiAmJiB0aGlzLmV4cGlyZXNBdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHBpcmVzQXQgPD0gbm93ICsgZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNhY2hlZCB0b2tlbiBvciByZXRyaWV2ZXMgYSBuZXcgb25lIGZyb20gR29vZ2xlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRUb2tlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUb2tlbihjYWxsYmFjaykge1xuICAgICAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgaWYgKF90eXBlb2YoY2FsbGJhY2spID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRzID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgb3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBmb3JjZVJlZnJlc2g6IGZhbHNlXG4gICAgICB9LCBvcHRzKTtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgY2IgPSBjYWxsYmFjaztcbiAgICAgICAgX2Fzc2VydENsYXNzQnJhbmQoX0dvb2dsZVRva2VuX2JyYW5kLCB0aGlzLCBfZ2V0VG9rZW5Bc3luYykuY2FsbCh0aGlzLCBvcHRzKS50aGVuKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIGNiKG51bGwsIHQpO1xuICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfYXNzZXJ0Q2xhc3NCcmFuZChfR29vZ2xlVG9rZW5fYnJhbmQsIHRoaXMsIF9nZXRUb2tlbkFzeW5jKS5jYWxsKHRoaXMsIG9wdHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEga2V5RmlsZSwgZXh0cmFjdCB0aGUga2V5IGFuZCBjbGllbnQgZW1haWwgaWYgYXZhaWxhYmxlXG4gICAgICogQHBhcmFtIGtleUZpbGUgUGF0aCB0byBhIGpzb24sIHBlbSwgb3IgcDEyIGZpbGUgdGhhdCBjb250YWlucyB0aGUga2V5LlxuICAgICAqIEByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHByaXZhdGVLZXkgYW5kIGNsaWVudEVtYWlsIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRDcmVkZW50aWFsc1wiLFxuICAgIHZhbHVlOiAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRDcmVkZW50aWFscyA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3IoKS5tKGZ1bmN0aW9uIF9jYWxsZWUyKGtleUZpbGUpIHtcbiAgICAgICAgdmFyIGV4dCwga2V5LCBib2R5LCBwcml2YXRlS2V5LCBjbGllbnRFbWFpbCwgX3ByaXZhdGVLZXksIF90O1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yKCkudyhmdW5jdGlvbiAoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyLm4pIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgZXh0ID0gcGF0aC5leHRuYW1lKGtleUZpbGUpO1xuICAgICAgICAgICAgICBfdCA9IGV4dDtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm4gPSBfdCA9PT0gJy5qc29uJyA/IDEgOiBfdCA9PT0gJy5kZXInID8gNCA6IF90ID09PSAnLmNydCcgPyA0IDogX3QgPT09ICcucGVtJyA/IDQgOiBfdCA9PT0gJy5wMTInID8gNiA6IF90ID09PSAnLnBmeCcgPyA2IDogNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlYWRGaWxlKGtleUZpbGUsICd1dGY4Jyk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGtleSA9IF9jb250ZXh0Mi52O1xuICAgICAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShrZXkpO1xuICAgICAgICAgICAgICBwcml2YXRlS2V5ID0gYm9keS5wcml2YXRlX2tleTtcbiAgICAgICAgICAgICAgY2xpZW50RW1haWwgPSBib2R5LmNsaWVudF9lbWFpbDtcbiAgICAgICAgICAgICAgaWYgKCEoIXByaXZhdGVLZXkgfHwgIWNsaWVudEVtYWlsKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JXaXRoQ29kZSgncHJpdmF0ZV9rZXkgYW5kIGNsaWVudF9lbWFpbCBhcmUgcmVxdWlyZWQuJywgJ01JU1NJTkdfQ1JFREVOVElBTFMnKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hKDIsIHtcbiAgICAgICAgICAgICAgICBwcml2YXRlS2V5OiBwcml2YXRlS2V5LFxuICAgICAgICAgICAgICAgIGNsaWVudEVtYWlsOiBjbGllbnRFbWFpbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm4gPSA1O1xuICAgICAgICAgICAgICByZXR1cm4gcmVhZEZpbGUoa2V5RmlsZSwgJ3V0ZjgnKTtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgX3ByaXZhdGVLZXkgPSBfY29udGV4dDIudjtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hKDIsIHtcbiAgICAgICAgICAgICAgICBwcml2YXRlS2V5OiBfcHJpdmF0ZUtleVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yV2l0aENvZGUoJyoucDEyIGNlcnRpZmljYXRlcyBhcmUgbm90IHN1cHBvcnRlZCBhZnRlciB2Ni4xLjIuICcgKyAnQ29uc2lkZXIgdXRpbGl6aW5nICouanNvbiBmb3JtYXQgb3IgY29udmVydGluZyAqLnAxMiB0byAqLnBlbSB1c2luZyB0aGUgT3BlblNTTCBDTEkuJywgJ1VOS05PV05fQ0VSVElGSUNBVEVfVFlQRScpO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JXaXRoQ29kZSgnVW5rbm93biBjZXJ0aWZpY2F0ZSB0eXBlLiBUeXBlIGlzIGRldGVybWluZWQgYmFzZWQgb24gZmlsZSBleHRlbnNpb24uICcgKyAnQ3VycmVudCBzdXBwb3J0ZWQgZXh0ZW5zaW9ucyBhcmUgKi5qc29uLCBhbmQgKi5wZW0uJywgJ1VOS05PV05fQ0VSVElGSUNBVEVfVFlQRScpO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmEoMik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMik7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBnZXRDcmVkZW50aWFscyhfeCkge1xuICAgICAgICByZXR1cm4gX2dldENyZWRlbnRpYWxzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0Q3JlZGVudGlhbHM7XG4gICAgfSgpKVxuICB9LCB7XG4gICAga2V5OiBcInJldm9rZVRva2VuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJldm9rZVRva2VuKGNhbGxiYWNrKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgX2Fzc2VydENsYXNzQnJhbmQoX0dvb2dsZVRva2VuX2JyYW5kLCB0aGlzLCBfcmV2b2tlVG9rZW5Bc3luYykuY2FsbCh0aGlzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gX2Fzc2VydENsYXNzQnJhbmQoX0dvb2dsZVRva2VuX2JyYW5kLCB0aGlzLCBfcmV2b2tlVG9rZW5Bc3luYykuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbmZ1bmN0aW9uIF9nZXRUb2tlbkFzeW5jKF94Mikge1xuICByZXR1cm4gX2dldFRva2VuQXN5bmMyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfZ2V0VG9rZW5Bc3luYzIoKSB7XG4gIF9nZXRUb2tlbkFzeW5jMiA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3IoKS5tKGZ1bmN0aW9uIF9jYWxsZWUzKG9wdHMpIHtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yKCkudyhmdW5jdGlvbiAoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDMubikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgaWYgKCEoX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KF9pbkZsaWdodFJlcXVlc3QsIHRoaXMpICYmICFvcHRzLmZvcmNlUmVmcmVzaCkpIHtcbiAgICAgICAgICAgIF9jb250ZXh0My5uID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmEoMiwgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KF9pbkZsaWdodFJlcXVlc3QsIHRoaXMpKTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIF9jb250ZXh0My5wID0gMTtcbiAgICAgICAgICBfY29udGV4dDMubiA9IDI7XG4gICAgICAgICAgcmV0dXJuIF9jbGFzc1ByaXZhdGVGaWVsZFNldChfaW5GbGlnaHRSZXF1ZXN0LCB0aGlzLCBfYXNzZXJ0Q2xhc3NCcmFuZChfR29vZ2xlVG9rZW5fYnJhbmQsIHRoaXMsIF9nZXRUb2tlbkFzeW5jSW5uZXIpLmNhbGwodGhpcywgb3B0cykpO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hKDIsIF9jb250ZXh0My52KTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIF9jb250ZXh0My5wID0gMztcbiAgICAgICAgICBfY2xhc3NQcml2YXRlRmllbGRTZXQoX2luRmxpZ2h0UmVxdWVzdCwgdGhpcywgdW5kZWZpbmVkKTtcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmYoMyk7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmEoMik7XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTMsIHRoaXMsIFtbMSwsIDMsIDRdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRUb2tlbkFzeW5jMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX2dldFRva2VuQXN5bmNJbm5lcihfeDMpIHtcbiAgcmV0dXJuIF9nZXRUb2tlbkFzeW5jSW5uZXIyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfZ2V0VG9rZW5Bc3luY0lubmVyMigpIHtcbiAgX2dldFRva2VuQXN5bmNJbm5lcjIgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yKCkubShmdW5jdGlvbiBfY2FsbGVlNChvcHRzKSB7XG4gICAgdmFyIGNyZWRzO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IoKS53KGZ1bmN0aW9uIChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0NC5uKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBpZiAoISh0aGlzLmlzVG9rZW5FeHBpcmluZygpID09PSBmYWxzZSAmJiBvcHRzLmZvcmNlUmVmcmVzaCA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICBfY29udGV4dDQubiA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hKDIsIFByb21pc2UucmVzb2x2ZSh0aGlzLnJhd1Rva2VuKSk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoISghdGhpcy5rZXkgJiYgIXRoaXMua2V5RmlsZSkpIHtcbiAgICAgICAgICAgIF9jb250ZXh0NC5uID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGtleSBvciBrZXlGaWxlIHNldC4nKTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGlmICghKCF0aGlzLmtleSAmJiB0aGlzLmtleUZpbGUpKSB7XG4gICAgICAgICAgICBfY29udGV4dDQubiA9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgX2NvbnRleHQ0Lm4gPSAzO1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldENyZWRlbnRpYWxzKHRoaXMua2V5RmlsZSk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjcmVkcyA9IF9jb250ZXh0NC52O1xuICAgICAgICAgIHRoaXMua2V5ID0gY3JlZHMucHJpdmF0ZUtleTtcbiAgICAgICAgICB0aGlzLmlzcyA9IGNyZWRzLmNsaWVudEVtYWlsIHx8IHRoaXMuaXNzO1xuICAgICAgICAgIGlmICghY3JlZHMuY2xpZW50RW1haWwpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzc0JyYW5kKF9Hb29nbGVUb2tlbl9icmFuZCwgdGhpcywgX2Vuc3VyZUVtYWlsKS5jYWxsKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYSgyLCBfYXNzZXJ0Q2xhc3NCcmFuZChfR29vZ2xlVG9rZW5fYnJhbmQsIHRoaXMsIF9yZXF1ZXN0VG9rZW4pLmNhbGwodGhpcykpO1xuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0LCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFRva2VuQXN5bmNJbm5lcjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9lbnN1cmVFbWFpbCgpIHtcbiAgaWYgKCF0aGlzLmlzcykge1xuICAgIHRocm93IG5ldyBFcnJvcldpdGhDb2RlKCdlbWFpbCBpcyByZXF1aXJlZC4nLCAnTUlTU0lOR19DUkVERU5USUFMUycpO1xuICB9XG59XG5mdW5jdGlvbiBfcmV2b2tlVG9rZW5Bc3luYygpIHtcbiAgcmV0dXJuIF9yZXZva2VUb2tlbkFzeW5jMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX3Jldm9rZVRva2VuQXN5bmMyKCkge1xuICBfcmV2b2tlVG9rZW5Bc3luYzIgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yKCkubShmdW5jdGlvbiBfY2FsbGVlNSgpIHtcbiAgICB2YXIgdXJsO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IoKS53KGZ1bmN0aW9uIChfY29udGV4dDUpIHtcbiAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0NS5uKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBpZiAodGhpcy5hY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgX2NvbnRleHQ1Lm4gPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdG9rZW4gdG8gcmV2b2tlLicpO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdXJsID0gR09PR0xFX1JFVk9LRV9UT0tFTl9VUkwgKyB0aGlzLmFjY2Vzc1Rva2VuO1xuICAgICAgICAgIF9jb250ZXh0NS5uID0gMjtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgcmV0cnk6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIF9hc3NlcnRDbGFzc0JyYW5kKF9Hb29nbGVUb2tlbl9icmFuZCwgdGhpcywgX2NvbmZpZ3VyZSkuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICBlbWFpbDogdGhpcy5pc3MsXG4gICAgICAgICAgICBzdWI6IHRoaXMuc3ViLFxuICAgICAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgICAgIGtleUZpbGU6IHRoaXMua2V5RmlsZSxcbiAgICAgICAgICAgIHNjb3BlOiB0aGlzLnNjb3BlLFxuICAgICAgICAgICAgYWRkaXRpb25hbENsYWltczogdGhpcy5hZGRpdGlvbmFsQ2xhaW1zXG4gICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmEoMik7XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTUsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfcmV2b2tlVG9rZW5Bc3luYzIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8qKlxuICogQ29uZmlndXJlIHRoZSBHb29nbGVUb2tlbiBmb3IgcmUtdXNlLlxuICogQHBhcmFtICB7b2JqZWN0fSBvcHRpb25zIENvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBfY29uZmlndXJlKCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHRoaXMua2V5RmlsZSA9IG9wdGlvbnMua2V5RmlsZTtcbiAgdGhpcy5rZXkgPSBvcHRpb25zLmtleTtcbiAgdGhpcy5yYXdUb2tlbiA9IHVuZGVmaW5lZDtcbiAgdGhpcy5pc3MgPSBvcHRpb25zLmVtYWlsIHx8IG9wdGlvbnMuaXNzO1xuICB0aGlzLnN1YiA9IG9wdGlvbnMuc3ViO1xuICB0aGlzLmFkZGl0aW9uYWxDbGFpbXMgPSBvcHRpb25zLmFkZGl0aW9uYWxDbGFpbXM7XG4gIGlmIChfdHlwZW9mKG9wdGlvbnMuc2NvcGUpID09PSAnb2JqZWN0Jykge1xuICAgIHRoaXMuc2NvcGUgPSBvcHRpb25zLnNjb3BlLmpvaW4oJyAnKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNjb3BlID0gb3B0aW9ucy5zY29wZTtcbiAgfVxuICB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyA9IG9wdGlvbnMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzO1xuICBpZiAob3B0aW9ucy50cmFuc3BvcnRlcikge1xuICAgIHRoaXMudHJhbnNwb3J0ZXIgPSBvcHRpb25zLnRyYW5zcG9ydGVyO1xuICB9XG59XG4vKipcbiAqIFJlcXVlc3QgdGhlIHRva2VuIGZyb20gR29vZ2xlLlxuICovXG5mdW5jdGlvbiBfcmVxdWVzdFRva2VuKCkge1xuICByZXR1cm4gX3JlcXVlc3RUb2tlbjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9yZXF1ZXN0VG9rZW4yKCkge1xuICBfcmVxdWVzdFRva2VuMiA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3IoKS5tKGZ1bmN0aW9uIF9jYWxsZWU2KCkge1xuICAgIHZhciBpYXQsIGFkZGl0aW9uYWxDbGFpbXMsIHBheWxvYWQsIHNpZ25lZEpXVCwgciwgX3Jlc3BvbnNlLCBfcmVzcG9uc2UyLCBib2R5LCBkZXNjLCBfdDI7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvcigpLncoZnVuY3Rpb24gKF9jb250ZXh0Nikge1xuICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ2Lm4pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGlhdCA9IE1hdGguZmxvb3IobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKTtcbiAgICAgICAgICBhZGRpdGlvbmFsQ2xhaW1zID0gdGhpcy5hZGRpdGlvbmFsQ2xhaW1zIHx8IHt9O1xuICAgICAgICAgIHBheWxvYWQgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGlzczogdGhpcy5pc3MsXG4gICAgICAgICAgICBzY29wZTogdGhpcy5zY29wZSxcbiAgICAgICAgICAgIGF1ZDogR09PR0xFX1RPS0VOX1VSTCxcbiAgICAgICAgICAgIGV4cDogaWF0ICsgMzYwMCxcbiAgICAgICAgICAgIGlhdDogaWF0LFxuICAgICAgICAgICAgc3ViOiB0aGlzLnN1YlxuICAgICAgICAgIH0sIGFkZGl0aW9uYWxDbGFpbXMpO1xuICAgICAgICAgIHNpZ25lZEpXVCA9IGp3cy5zaWduKHtcbiAgICAgICAgICAgIGhlYWRlcjoge1xuICAgICAgICAgICAgICBhbGc6ICdSUzI1NidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICAgICAgc2VjcmV0OiB0aGlzLmtleVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIF9jb250ZXh0Ni5wID0gMTtcbiAgICAgICAgICBfY29udGV4dDYubiA9IDI7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdCh7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIHVybDogR09PR0xFX1RPS0VOX1VSTCxcbiAgICAgICAgICAgIGRhdGE6IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgICBncmFudF90eXBlOiAndXJuOmlldGY6cGFyYW1zOm9hdXRoOmdyYW50LXR5cGU6and0LWJlYXJlcicsXG4gICAgICAgICAgICAgIGFzc2VydGlvbjogc2lnbmVkSldUXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgcmV0cnlDb25maWc6IHtcbiAgICAgICAgICAgICAgaHR0cE1ldGhvZHNUb1JldHJ5OiBbJ1BPU1QnXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgciA9IF9jb250ZXh0Ni52O1xuICAgICAgICAgIHRoaXMucmF3VG9rZW4gPSByLmRhdGE7XG4gICAgICAgICAgdGhpcy5leHBpcmVzQXQgPSByLmRhdGEuZXhwaXJlc19pbiA9PT0gbnVsbCB8fCByLmRhdGEuZXhwaXJlc19pbiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogKGlhdCArIHIuZGF0YS5leHBpcmVzX2luKSAqIDEwMDA7XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hKDIsIHRoaXMucmF3VG9rZW4pO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgX2NvbnRleHQ2LnAgPSAzO1xuICAgICAgICAgIF90MiA9IF9jb250ZXh0Ni52O1xuICAgICAgICAgIHRoaXMucmF3VG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy50b2tlbkV4cGlyZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgYm9keSA9IF90Mi5yZXNwb25zZSAmJiAoX3Jlc3BvbnNlID0gX3QyLnJlc3BvbnNlKSAhPT0gbnVsbCAmJiBfcmVzcG9uc2UgIT09IHZvaWQgMCAmJiBfcmVzcG9uc2UuZGF0YSA/IChfcmVzcG9uc2UyID0gX3QyLnJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfcmVzcG9uc2UyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVzcG9uc2UyLmRhdGEgOiB7fTtcbiAgICAgICAgICBpZiAoYm9keS5lcnJvcikge1xuICAgICAgICAgICAgZGVzYyA9IGJvZHkuZXJyb3JfZGVzY3JpcHRpb24gPyBcIjogXCIuY29uY2F0KGJvZHkuZXJyb3JfZGVzY3JpcHRpb24pIDogJyc7XG4gICAgICAgICAgICBfdDIubWVzc2FnZSA9IFwiXCIuY29uY2F0KGJvZHkuZXJyb3IpLmNvbmNhdChkZXNjKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgX3QyO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hKDIpO1xuICAgICAgfVxuICAgIH0sIF9jYWxsZWU2LCB0aGlzLCBbWzEsIDNdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9yZXF1ZXN0VG9rZW4yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gtoken/build/cjs/src/index.cjs\n");

/***/ })

};
;